---
title: 继续多线程
date: 2017-02-27 11:18:11
tags:
categories:
- 多线程
- Java
- 学习笔记
---

### 一些用于多线程的工具。

<!-- more -->

#### CopyOnWriteArrayList 和 CopyOnWriteArraySet

读写分离思想，在某个线程要写数据时，复制一份进行修改，在修改完成后设置给列表。
基本原理如下：

```java
public boolean add(E e){
    final ReentrantLock = this.lock();
    lock.lock();
    try{
        Object[] elements = getArray();
        int length = element.length;
        Object[] newElements = Arrays.copyOf(elements,length + 1);
        newElements[length] = e;
        setArray(newElements);
        return true;
    }finally{
        lock.unlock();
    }
}
```

#### ConcurrentHashMap

我们知道，HashTable 是 HashMap 的线程安全的实现，但 HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下，HashTable 的效率非常低下。所有线程都要竞争同一把锁。

ConcurrentHashMap 使用了锁分段技术，首先将数据分成一段一段的存储，然后给每一段配一把锁，当一个线程占用锁访问其中一个段数据时，其它段的数据也能被其它线程访问。有些方法需要跨段，如size()和containsValue(),他们可能需要锁定整个表而不仅是某个段，操作完毕后，又按顺序释放所有的锁。

#### BlockingQueue -- 阻塞队列

| 函数                 | 作用         | 
| ------------------- |---------------| 
| add(e)     | 把元素 e 加到 BlockingQueue 里，如果 BlockingQueue 可以容纳，则返回 true,否则抛出异常。 | 
| offer(e)      | 把元素 e 加到 BlockingQueue 里，如果 BlockingQueue 可以容纳，则返回 true,否者返回 false。 |  
| offer(e，time,unit) | 把元素 e 加到 BlockingQueue 里，如果 BlockingQueue 可以容纳，则返回 true;否者等待 time 时间后尝试添加，再次失    败返回 false。      | 
| put(e) | 把元素 e 加到 BlockingQueue 里，如果 BlockingQueue 不能容纳，阻塞当前线程，知道被加入。|
| take() | 取走 BlockingQueue 队首的对象，如果队列为空，那么等待插入值后再取 |
| poll(time,unit) | 取出并移除队列中的队首元素，如果设定的的阻塞时间内还没有获得数据，那么返回null |
| element() | 获取队首元素，如果队列为空，那么抛出 NoSuchElementException 异常 |
| peek() | 获取队首元素，如果队列为空，返回null |
| remove() | 获取并移除队首元素，如果队列为空，那么抛出 NoSuchElementException 异常 |


JDK 中有多个 BlockingQueue 的实现。比如 ArrayBlockingQueue、LinkedBlockingQueue 等.再次不做更深的介绍，相信看类名都知道具体实现之间的区别。

### 同步锁

#### synchronized 

每一个对象都有一个锁。对象、函数、类的本质都是对象，所以都可以加锁。

几种加锁的方法：

```java
public class SynchronizedDemo{
    public synchronized void syncMethod(){
        //do s.th
    }

    public void syncThis(){
        synchronized(this){
            //do s.th
        }
    }

    public void syncClass(){
        synchronized(SynchronizedDemo.class){
            //do s.th
        }
    }

    public synchronized static void syncStaticMethod(){
        //do s.th
    }
}
```

对于锁 class 对象来说，它的作用是防止多个线程同时访问添加了 synchronized 锁的代码块。而 synchronized 作用于引用对象是防止其它线程访问同一个对象中的 synchronized 代码块或者函数。
PS：上一段要理解到位。

#### 显式锁 -- ReentrantLock 和 Condition

##### ReentrantLock

Java 6.0 增加了该机制。与内置锁 synchronized 相比，实现了相同语义，但是灵活性更高。
1.获取和释放的灵活性
2.轮训锁和定时锁
3.公平性

内置锁的获取和释放都在同一个代码块中，而显式锁则可以将锁的获得和释放分开。同时，显示锁可以提供轮训锁和定时锁，同时可以提供公平锁或者非公平锁。

ReentrantLock 的基本操作如下表：

| 函数        | 作用    | 
| --------   | -----  |
| lock() | 获取锁 |
| tryLock() | 尝试获取锁(如果没获取到，那么还会阻塞吗？跟lock()的区别？) |
| tryLock(longtimetout,TimeUnit) | 尝试获取锁，如果到了指定的时间还获取不到，那么超时 |
| unlock() | 释放锁 |
| newCondition() | 获取锁的 Condition |

常用的使用形式：

```java
Lock lock = new ReentrantLock();

public void doSth({
    lock.lock();
    try{
        //do s.th
    }finally{
        lock.unlock(); // 此处是一个潜在的大坑，必须在此处释放锁。这就是为什么 synchronized 还没有被取代的原因。（因为 synchronized 会被 JVM 释放）
    }
})
```

##### Condition

Condition 绑定在 ReentrantLock 上的，表示 ReentrantLock 的一个条件。用于实现线程间的通信（主要用在同步），解决了 wait()、notify()、notifyAll() 不好用。

Condition 为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程。

| 函数        | 作用    | 
| --------   | -----  |
| await() | 线程等待  |
| await(int time,TimeUnit) | 线程等待指定的时间，超时怎么处理？|
| signal() | 随机唤醒某个等待该条件的线程 |
| signalAll() | 唤醒所有等待该条件的线程 | 

一个简单的示例:

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Main {

    private static final Lock lock = new ReentrantLock();

    private static Condition condition = lock.newCondition();


    public static void main(String[] args) {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000); // 主动等待1s钟，让thread2先获得同步锁
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    return;
                }
                lock.lock();
                try {
                    Thread.sleep(3000);
                    condition.signal();       // 通知条件已经实现
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    lock.unlock();            // 释放同步锁
                }
                System.out.println("Thread 1 end");
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                lock.lock();
                try {
                    condition.await(); // 线程进入阻塞，同时释放同步锁，让thread1
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    lock.unlock();
                }
                System.out.println("Thread 2 end");
            }
        });

        thread1.start();
        thread2.start();
    }
}
```
output:

```java
Thread 1 end
Thread 2 end
```


#### 信息量 Semaphore

Semaphore 是一个计数信号量，它的本质时一个“共享锁”。信号量维护了一个信号量许可集，线程可以通过调用 acquire() 来获取信号量的许可；否则线程必须等待，直到有可以用的许可为止。线程通过 release() 来其持有的信号量许可。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class Main {

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        Semaphore semaphore = new Semaphore(3);
        for(int i = 0;i < 10;i++){
            Thread.sleep(400);
            executorService.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        semaphore.acquire();
                        System.out.println("acquire后 剩余许可 " + semaphore.availablePermits());
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        semaphore.release();
                        System.out.println("release后 剩余许可 " + semaphore.availablePermits());
                    }
                }
            });
        }
    }
}
```

#### 循环栅栏 CyclicBarrier

CyclicBarrier 是一个同步辅助类，允许一组线程相互等待，知道达到某个公共屏障点。

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class Main {

    private static CyclicBarrier mCyclicBarrier;

    public static void main(String[] args) {

        // 第二个参数是当等待线程开始执行之前调用的
        mCyclicBarrier = new CyclicBarrier(5, new Runnable() {
            @Override
            public void run() {
                System.out.println("满足条件，开始调度线程");
            }
        });

        for(int i = 0;i < 20;i++){
            int finalI = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        System.out.println("线程开始了——————" + finalI);
                        mCyclicBarrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }finally {
                        // 哈哈 我发现这个不需要释放
                    }
                }
            }).start();
        }
    }
}
```

output

```java
线程开始了——————0
线程开始了——————1
线程开始了——————3
线程开始了——————2
线程开始了——————4
满足条件，开始调度线程
线程开始了——————5
线程开始了——————6
线程开始了——————7
线程开始了——————8
线程开始了——————9
满足条件，开始调度线程
线程开始了——————10
线程开始了——————11
线程开始了——————12
线程开始了——————13
线程开始了——————14
满足条件，开始调度线程
线程开始了——————15
线程开始了——————16
线程开始了——————17
线程开始了——————18
线程开始了——————19
满足条件，开始调度线程
```

#### 闭锁 CountDownLatch

CountDownLatch 也是一个同步辅助类，在完成一组正在其它线程中执行的操作之前，它允许一个或者多个线程一直等待，直到条件被满足。

```java
import java.util.concurrent.CountDownLatch;

public class Main {

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(5);
        for(int i = 0;i < 5;i++){
            int finalI = i;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println("执行线程 " + finalI);
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    latch.countDown();
                }
            }).start();
        }
        latch.await();
        System.out.println("执行主线程");
    }
}
```

output

```java
执行线程 0
执行线程 1
执行线程 2
执行线程 3
执行线程 4
执行主线程
```